\documentclass[12pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[czech]{babel}
\usepackage[a4paper, top=4cm, bottom=3cm, left=3cm, right=3cm]{geometry}
\setlength{\parskip}{1em}
\usepackage[htt]{hyphenat}

\title{Diskrétní simulace za použití knihovny SimPy}
\author{Panovský Tomáš}
\date{\today}

\begin{document}

\maketitle

\section{Úvod}
V této bakalářské práci se zabývám diskrétní simulací za použití knihovny SimPy v Pythonu. 
Knihovna Simpy umožňuje modelovat procesy, jenž probíhají souběžně, a mohou být zastaveny, nebo pozastaveny na určitou dobu. Praktická část bakalářské práce obsahuje aplikaci simulující průběh hudebního festivalu.
Cílem simulace je zjistit, jak se návštěvníci pohybují a kde vznikají 
fronty, což může pomoci při organizaci reálného festivalu.

\section{Systém} str17
Reálnou skutečnost, kterou chceme analyzovat, označujeme jako systém. Analyzovat znamená sledovat, jak se různé části systému chovají v čase, a vyvozovat závěry o efektivitě, kapacitě nebo chování systému.

Na systémy můžeme nahlížet jako diskrétní nebo spojité, přičemž záleží na úhlu pohledu a vlastnostech, které v systému převažují. {\bf Diskrétní systém je takový, u kterého se stavové proměnné mění pouze v diskrétních časových okamžicích.} Příkladem diskrétního systému je hudební festival, kde se stavové proměnné, například počet návštěvníků ve frontě u stánku s pivem, mění pouze tehdy, když návštěvník přijde na řadu, nebo dostane pivo a odejde. Oproti tomu spojitý systém je takový systém, u kterého se stavové proměnné mění plynule v čase, nikoli pouze v diskrétních okamžicích.

{\bf Stav systému je definován jako soubor stavových proměnných, které jsou nezbytné k popisu systému v libovolném okamžiku.} V simulaci hudebního festivalu mohou být možné stavové proměnné například počet lidí čekajících ve frontách u stánků s občerstvením, počet lidí právě sledujících koncert, nebo čas příchodu dalšího návštěvníka do areálu.


\subsection{Komponenty systému}
Každý systém lze chápat jako soubor vzájemně propojených prvků, které společně ovlivňují jeho chování. Aby bylo možné systém lépe pochopit, je vhodné rozdělit jej na základní komponenty, které popisují jeho strukturu a dynamiku. Mezi tyto komponenty patří entity, jejich atributy, aktivity a události.

\noindent \textbf{Entita} je objekt zájmu v systému. V našem případě mohou být entitami například návštěvníci festivalu, stánky s občerstvením nebo pódium.

\noindent \textbf{Atribut} je vlastnost entity, například počet lidí u stánku, nebo informace o tom, zda má návštěvník hlad nebo je unavený. 

\noindent \textbf{Aktivita} představuje časově omezenou činnost entity, například čekání ve frontě, sledování koncertu nebo nákup jídla.

\noindent \textbf{Událost} je okamžitá změna stavu systému. Události dělíme na Endogenní a Exogenní. Endogenní probíhají uvnitř systému a jsou způsobeny chováním jeho komponent, např. návštěvník dokončí konzumaci jídla a odchází od stánku. Exogenní probíhají v prostředí systému a ovlivňují ho zvenčí, například náhlý déšť.


\section{Úvod do simulace}  str6
Simulace je napodobení systému v čase. Cílem je vytvořit umělou historii stavu daného systému, a následně pozorovat tuto uměle vytvořenou historii za účelem vyvození závěrů o provozních vlastnostech systému, tedy o měřitelných charakteristikách a výkonnosti systému, jako je například délka front u stánků, průměrná doba čekání návštěvníků nebo hustota návštěvníků u pódia. 

Chování systému vyvíjejícího se v čase se zkoumá pomocí simulačního modelu. V této práci je simulační model vytvořen v knihovně SimPy. Simulační model poté může být použit k prozkoumání široké škály otázek typu „co by se stalo, kdyby“ týkajících se reálného systému. Například můžeme zkoumat, zda je daný počet stánků s občerstvením dostatečný pro obsloužení všech návštěvníků festivalu bez dlouhých front. 

Možné změny systému pak lze nejprve nasimulovat, aby bylo možné předpovědět jejich dopad na výkonnost systému. Simulace může být také použita ke studiu systémů ve fázi návrhu, ještě před jejich samotnou realizací.

\section{Model systému} str. 13
{\bf Model je definován jako reprezentace systému za účelem jeho studia.} Pro většinu studií je nutné zvažovat pouze ty aspekty systému, které ovlivňují problém, který je předmětem zkoumání. 

Modely lze klasifikovat jako statické nebo dynamické, deterministické nebo stochastické a diskrétní nebo spojité. Statický simulační model reprezentuje systém v určitém časovém okamžiku, zatímco dynamické modely reprezentují systémy, jak se mění v čase. Deterministické simulační modely neobsahují žádné náhodné prvky, a to ani ve vstupních datech, ani v průběhu samotné simulace. Při opakovaném spuštění se stejnými vstupy poskytují vždy totožný průběh i výsledek simulace. Stochastické modely naproti tomu obsahují jeden nebo více náhodných prvků, které mohou vstupovat do simulace jak na jejím začátku, tak v jejím průběhu, například při generování časů událostí nebo rozhodování o chování entit. Díky tomu lépe vystihují systémy, jejichž chování je ovlivněno náhodou. Výsledky takových simulací nejsou jednoznačné, ale mají pravděpodobnostní charakter. Diskrétní a spojité modely jsou definovány obdobně jako u systémů.

Pro studium hudebního festivalu použijeme diskrétní, dynamický a stochastický model. Diskrétní model, protože stavové proměnné se mění pouze v konkrétních okamžicích. Dynamický model, protože sleduje vývoj systému v čase během celé doby trvání festivalu. Stochastický model, protože některé vstupy, například časy příchodů návštěvníků, doba čekání u stánku nebo délka sledování koncertu, jsou náhodné.

\section{Simulace v SimPy}
Pro realizaci diskrétní simulace jsem zvolil jazyk Python a knihovnu SimPy. Ta je postavena především na generátorech (využívající příkaz \texttt{yield}), které umožňují popis aktivit a událostí entit.

\subsection{Generátory v Pythonu}
V jazyce Python je iterátor objekt, který umožňuje postupné získávání hodnot bez nutnosti mít všechny hodnoty uložené v paměti. Iterátor si pamatuje svůj aktuální stav a při každém volání funkce next() vrací další prvek.

Zvláštní formou iterátorů jsou generátory, které obsahují v těle funkce příkaz \texttt{yield}. Příkaz \texttt{yield} umožňuje generátoru postupně produkovat jednotlivé prvky posloupnosti a může teoreticky produkovat i nekonečnou posloupnost dat. Posloupnost zde znamená řadu hodnot, které generátor postupně poskytuje. Příkaz produkující prvek posloupnosti nabývá tvaru: \texttt{yield element}. Po provedení příkazu yield se generátor pozastaví a vrátí hodnotu specifikovanou příkazem \texttt{yield}. Při dalším volání pokračuje ve vykonávání od místa, kde byl přerušen.

\noindent Příklad generátoru:
 \begin{verbatim} 
def get_numbers():
   i = 0
   while True:
      yield i
      i = i + 1
\end{verbatim}
Napřed pouze vytvoříme iterátor i: 
 \begin{verbatim} 
i = get_numbers()
\end{verbatim}
Další prvek můžeme vyžádat funkcí next. 
Dalším prvkem posloupnosti bude hodnota určená příkazem yield. Tedy:
 \begin{verbatim} 
next(i)
\end{verbatim}
V tuto chvíli bude v proměnné i uložena 0. Tělo generátoru se začne vykonávat od pozastaveného místa až po příkaz yield.  Vykonávání těla generátoru je pozastaveno na řádku:
 \begin{verbatim} 
i = i + 1
\end{verbatim}
Popsaným způsobem získáme další hodnoty z generátoru, tedy při dalším volání \texttt{next(i)} bude v proměnné \texttt{i} 1, poté 2, a tak dále.

V kontextu diskrétní simulace v knihovně SimPy jsou generátory využity k modelování aktivit, které představují chování jednotlivých entit, například návštěvníků festivalu. Každý příkaz \texttt{yield} v generátoru odpovídá předání řízení simulátoru a obvykle vrací objekt typu \texttt{Event}, který reprezentuje událost, na jejíž dokončení aktivita čeká. Příkladem může být čekání ve frontě u stánku s jídlem, dokončení přípravy jídla či jeho obdržení zákazníkem. Takto lze simulovat souběžné aktivity více entit a stochastické prvky, například náhodné časy příprav nebo příchodů návštěvníků, což odpovídá reálnému chování systému.

\subsection{Základní principy SimPy}
Základní komponenty SimPy jsou prostředí simulace (jenž je v SimPy označováno jako Environment), události a procesní funkce. Smyslem prostředí je řídit celou simulaci, udržovat simulační čas a organizovat události. Události udávají, kdy má dojít ke změně stavu a společně tvoří časový plán simulace. Procesní funkce jsou python generátorové funkce, které generují události. Smyslem procesních funkcí je popisovat chování entit v simulaci. Na každou procesní funkci můžeme nahlížet jako na aktivity dané entity. Voláním procesní funkce vzniká entita, jejiž chování popisuje iterátor funkcí vrácený. Jeden z argumentů volání procesní funkce je vždy prostředí. Instance procesní funkce běžící v simulačním prostředí v kontextu SimPy a programového řízení simulace nazýváme proces.

Prostředí simulace řídí průběh simulační času a spravuje seznam plánovaných událostí. Simulační čas je čas, ve kterém simulace probíhá, nikoliv reálný čas. V SimPy je tento čas oproti reálnému času bez konkrétní jednotky a probíhá diskrétně. Simulační čas jsou tedy pouze diskrétní hodnoty jako například 0, 1, 2 a podobně. Jednotky času si můžeme určit sami podle toho, co simulujeme. Mohou to být například hodiny, minuty či sekundy. Standardně čas začíná hodnotou 0. Aktuální čas simulace můžeme získat zasláním zprávy \texttt{env.now()}. Každá událost má přiřazený čas, ve kterém nastane. Prostředí tedy vždy zpracuje událost naplánovanou na aktuální čas.

Jednotlivé aktivity reprezentované procesní funkcí mohou probíhat nezávisle na sobě. To, že aktivita probíhá nějakou dobu, lze v SimPy simulovat události \texttt{enviroment.timeout(time)}, která procesní funkci na stanovený čas pozastaví. Během doby, kdy je procesní funkce pozastavena, může prostředí vykonávat jiné události naplánované na aktuální čas simulace. K pozastavení procesní funkce dochází ve chvíli, kdy entita provádí časově omezenou aktivitu. Pozastavený proces tedy představuje období, během kterého simulovaná entita vykonává danou aktivitu. Procesní funkce lze pozastavit i dalšími typy událostí, které budou vysvětleny později.

Každá událost v SimPy má prioritu. Priorita je číslo, podle kterého se rozhoduje, která událost se zpracuje dříve, pokud je více událostí naplánovaných na stejný simulační čas.
Ve výchozím nastavení mají všechny události stejnou prioritu, lze ji ale ručně nastavit, což umožňuje řídit pořadí zpracování, například aby určitá událost vždy předběhla jinou událost ve stejném časovém okamžiku. Avšak ve většině simulací, včetně této, není potřeba ruční nastatování priorit.

Každá událost má také interní identifikátor, který prostředí používá pro rozlišení dvou událostí se stejným časem a prioritou.
Identifikátor se zvyšuje s každou novou událostí, takže simulace ví, která událost byla vytvořena dříve a měla by být zpracována první.

\noindent Abychom ilustrovali, jak SimPy pracuje s procesními funkcemi a jak mezi nimi přepíná pomocí událostí, si představme jednoduchý scénář se dvěma roboty, kteří se pohybují v různých směrech. Každý robot představuje samostatnou entitu se svou vlastní aktivitou, která nějakou dobu trvá. Právě tuto dobu můžeme v SimPy modelovat  událostí \texttt{env.timeout()}. V následujícím příkladu vznikne zavoláním procesní funkce \texttt{robot} entita \texttt{Robot A} a entita \texttt{Robot B} .
Tělo procesní funkce zařídí, že vzniklý robot po náhodně dlouhou dobu půjde směrem vlevo nebo vpravo a poté se na jednu časovou jednotku zastaví. Pro určení doby, jak dlouho se roboti budou pohybovat použijeme modul \texttt{random} ze standardní knihovny Pythonu. Prostředí simulace mezi těmito dvěma aktivitami automaticky přepíná vždy ve chvíli, kdy některý z robotů čeká na dokončení události \texttt{timeout.}

 \begin{verbatim} 
env = simpy.Environment()

def robot(env, name, direction):
    while True:
        print(f"{env.now}: {name} se začal pohybovat směrem {direction}")
        yield env.timeout(random.randint(1, 3))
        print(f"{env.now}: {name} se zastavil a rozhlíží se")
        yield env.timeout(1)       

env.process(robot(env, "Robot A", "vpravo"))
env.process(robot(env, "Robot B", "vlevo"))
env.run()
\end{verbatim}

\noindent Nejprve je vytvořeno prostředí simulace \texttt{env}. Následně je definována procesní funkce \texttt{robot}, která představuje aktivitu jednoho robota. Procesní funkci je v argumentech předáno simulační prostředí \texttt{env}, jméno robota \texttt{name} a směr \texttt{direction}, kterým robot bude chodit. Prostředí následně pomocí zavolání env.process() zaregistrovalo procesní funkce \texttt{robot}, čímž došlo k vytvoření entit robotů. SimPy tak může řídit průběh jejích aktivit prostřednictvím událostí. Nakonec je simulace spuštěna zasláním zprávy \texttt{env.run()}. Výstup tohoto příkladu by vypadal následovně:

 \begin{verbatim} 
0: Robot A se začal pohybovat směrem vpravo
0: Robot B se začal pohybovat směrem vlevo
2: Robot A se zastavil a rozhlíží se
2: Robot A se začal pohybovat směrem vpravo
3: Robot B se zastavil a rozhlíží se
4: Robot B se začal pohybovat směrem vlevo
.
.
.
\end{verbatim}

\subsection{Prostředí simulace}
Již víme, že simulační prostředí spravuje čas simulace, plánování a zpracování událostí, a poskytuje také prostředky pro postupné provádění simulace. Mimo to SimPy také nabízí simulační prostředí \texttt{RealtimeEnvironment}, které simulační čas synchronizuje s reálným časem. To umožňuje například běh simulace paralelně s reálnými událostmi, kdy čas simulace plyne stejně jako skutečný čas, to však v této práci nevyužijeme.

Další funkce prostředí je obsluha spuštění simulace. Simulace v SimPy se spouští zasláním zprávy \texttt{env.run()}, kde případný argument této zprávy záleží na tom, kdy má simulace skončit. Simulace obvykle končí po vyčerpání všech událostí, nebo po uplynutí předem stanoveného času. Pokud chceme, aby simulace skončila po vyčerpání všech naplánovaných událostí, necháme zprávu \texttt{env.run()} bez argumentu. Speciálním případem takto spuštěné simulace může být nekonečná simulace, a to například když kód procesní funkce běží ve smyčce \texttt{while True:}, jako jsme si ukázali v příkladu s roboty. Tato simulace samovolně nikdy neskončí a musíme ji ukončit násilně.
V případě, že chceme ukončit simulaci po uplynutí předem stanoveného času zašleme zprávu \texttt{env.run()} s argumentem \texttt{until=time}, kde \texttt{time} je hodnota datového typu \texttt{integer}, na které se má simulační čas zastavit, například \texttt{env.run(until=10)}. Simulace se zastaví v okamžiku, kdy čas dosáhne hodnoty 10, ale neprovede žádné události naplánované na čas 10. Poslední variantou je spuštění simulace do doby, než nenastane konkrétní událost \texttt{env.run(until=event)}. 

Prostředí také poskytuje metody pro ruční krokování simulace, to je užitečné zejména pro testování a ladění simulace po jednotlivých krocích. Zaslání zprávy \texttt{peek()} vrací čas nejbližší naplánované události, aniž by byla událost vykonána, což umožňuje kontrolu plánovaného průběhu simulace. Zaslání zprávy \texttt{step()} zpracuje nejbližší naplánovanou událost a posune aktuální čas simulace na čas této události. Pokud nejsou k dispozici žádné další události, vyvolá metoda výjimku \texttt{EmptySchedule}, čímž signalizuje konec simulace. 

Zprávy \texttt{peek()} a \texttt{step()} si ukážeme na následujícím jednoduchém příkladu, kde budeme mít dvě procesní funkce \texttt{procesni\_funkce\_1} a \texttt{procesni\_funkce\_2}, a každá procesní funkce představuje jednoduchou aktivitu, která u první funkce trvá 3 časové jednotky a u druhé 5 časových jednotek.

 \begin{verbatim} 
def procesni_funkce_1(env):
    print(f"t = {env.now}: start aktivity_1")
    yield env.timeout(3)
    print(f"t = {env.now}: konec aktivity_1")

def procesni_funkce_2(env):
    print(f"t = {env.now}: start aktivity_2")
    yield env.timeout(5)
    print(f"t = {env.now}: konec aktivity_2")

env = simpy.Environment()
env.process(procesni_funkce_1(env))
env.process(procesni_funkce_2(env))

\end{verbatim}

\noindent Následně budeme na střídavě zasílat zprávy \texttt{peek()} a \texttt{step()}. Připomeňme, že \texttt{peek()}  vrací čas nejbližší naplánované události, a \texttt{peek()} zpracuje nejbližší událost.

 \begin{verbatim} 
print(env.peek())
env.step()
print(env.peek())
env.step()
print(env.peek())
env.step()
print(env.peek())
env.step()
print(env.peek())
env.step()
print(env.peek())
env.step()
\end{verbatim}

\noindent První zaslání zprávy \texttt{peek()} vrátí 0, protože start procesů \texttt{procesni\_funkce\_1} a \texttt{procesni\_funkce\_2} je naplánován na čas 0. 
Po prvním zaslání zprávy \texttt{env.step()} se spustí první proces \texttt{procesni\_funkce1} a vypíše se: \texttt{t = 0: start aktivity\_1}
Proces narazí na \texttt{yield env.timeout(3)}, což naplánuje timeout událost v čase 3. Druhé zaslání zprávy \texttt{peek()} vrátí 0, protože další nejbližší událost (start druhého procesu \texttt{procesni\_funkce2}) je stále naplánovaná na čas 0. Druhé zaslání zprávy \texttt{env.step()} spustí start druhého procesu \texttt{procesni\_funkce2} a vypíše se: \texttt{t = 0: start aktivity\_2}. Proces narazí na \texttt{yield env.timeout(5)}, což naplánuje timeout událost v čase 5. Třetí volání \texttt{peek()} vrátí 3, protože nejbližší naplánovaná událost je timeout prvního procesu. Třetí zaslání zprávy \texttt{env.step()} zpracuje timeout první procesní funkce. Simulační čas se posune na 3 a proces dokončí svou aktivitu: \texttt{t = 3: konec aktivity\_1}. Čtvrté zaslání zprávy \texttt{peek()} ukazuje nejbližší naplánovanou událost, což je tentorkát dokončení procesu \texttt{procesni\_funkce\_1} v čase 3. V SimPy se totiž i ukončení procesu zapisuje jako událost do plánovače. Proto po dokončení těla procesní funkce ještě jedno \texttt{step()} finalizuje proces (nastaví jeho stav na finished), ale nevypíše žádný text z těla funkce. Pátá zpráva \texttt{step()} tedy nic nevypíše a pouze ukončí první proces.
Tímto způsobem bychom pokračovali až do zaslání sedmé zprávy \texttt{env.step()}, která by už vyhodila výjimku \texttt{EmptySchedule}, protože v plánu simulace nejsou další události, což signalizuje konec simulace.

\noindent Výstup by tedy vypadal následovně.

 \begin{verbatim} 
0
t = 0: start aktivity_1
0
t = 0: start aktivity_2
3
t = 3: konec aktivity_1
3
5
t = 5: konec aktivity_2
5
\end{verbatim}


\subsection{Události}
SimPy vytváří události prostřednictvím modulu \texttt{simpy.events}. Základní třídou pro všechny události je \texttt{simpy.events.Event}, která definuje společné vlastnosti a metody, jenž dědí všechny specializované typy událostí. I když lze třídu Event použít přímo, SimPy nabízí několik specializovaných podtříd pro různé účely.

\subsubsection{Specializované události}

Z předešlých kapitol již víme, že \texttt{Timeout} je speciální událost, která je dokončena po uplynutí zadaného času. Používá se pro simulaci aktivity,která trvá určitou dobu.
 \texttt{Initialize} je událost, která signalizuje inicializaci komponenty a využívá obvykle interně v SimPy. Komponentou je například objekt \texttt{Resource}, který představuje přístup k omezenému zdroji. O nich se více dozvíme později. \texttt{Process} je událost reprezentující běh generátorové funkce. Dokončení této události znamená, že skončila nějaká aktivita. \texttt{Condition} je abstraktní třída pro složitější podmínky, které závisí na jiných událostech. \texttt{AllOf} je podmíněná událost, která je dokončena až tehdy, když všechny zadané události jsou dokončeny. \texttt{AnyOf} je podmíněná událost, která je dokončena, jakmile je dokončena alespoň jedna zadaná událost.

\subsubsection{Stavy událostí}

Každá událost může být v jednom ze tří stavů: může nastat \texttt{(not triggered)}, má nastat \texttt{(triggered)}, nebo nastala \texttt{(processed)}. Každá událost projde těmito stavy přesně jednou a vždy v uvedeném pořadí. Události jsou úzce spjaty s časem simulace, který řídí jejich přechod mezi stavy. Po vytvoření je událost ve stavu \texttt{(not triggered)}, to znamená, že událost ještě není aktivována, ale jde pouze o objekt v paměti. Když je událost naplánována na určitý čas, přejde do stavu \texttt{triggered} a atribut \texttt{Event.triggered} je nastaven na \texttt{True}. Událost v tomto stavu čeká na svůj časový okamžik, kdy bude zpracována. Dokud událost není zpracována, lze k ní přidávat callbacky. Událost přejde do stavu  \texttt{processed} jakmile byla dokončena a všechny callbacky byly spuštěny.

\subsubsection{Callbacky}

\texttt{Callbacky} jsou funkce, které se spustí ve chvíli, kdy je událost dokončena. Každá událost v SimPy si interně udržuje seznam callbacků, do kterého lze přidávat nové funkce. Jakmile je událost dokončena, SimPy tento seznam projde a všechny uložené callbacky vykoná. Procesní funkce, která čeká na nějakou událost (např. \texttt{yield env.timeout(...)}), je automaticky zaregistrována jako jeden z callbacků této události. Díky tomu se po jejím dokončení procesní funkce znovu aktivuje a pokračuje přesně na místě, kde byla pozastavena. Tento mechanismus umožňuje přirozené střídání aktivit a souběh více entit, aniž by bylo nutné jejich běh řídit manuálně. Callback tedy reaguje na dokončení události. Aktivity, které čekají na událost, jsou jedním typem callbacků. Můžeme si ale callbacky definovat i explicitně, například pokud chceme, aby se po dokončení timeout události spustila nějaká další funkce. Jelikož jsou callbacky nízkoúrovňový mechanismus, který SimPy používá interně, umožňují reagovat na událost i bez definování procesních funkcí, jak si ukážeme v jednoduchém následujícím příkladu.

 \begin{verbatim} 
def my_callback(event):
    print(f"Událost dokončena v čase {event.env.now}")

env = simpy.Environment()
event = env.timeout(3)
event.callbacks.append(my_callback)

env.run()
\end{verbatim}

Vytvořili jsme timeout událost na 3 časové jednotky a uložili ji do proměnné \texttt{event}. Tu je nutné v argumentu volání předat callbacku.  Přidali jsme callback \texttt{my\_callback}, tedy funkci, která se zavolá, jakmile událost \texttt{event} skončí. Když prostředí zpracuje událost, zavolá callback a vypíše se na výstup zpráva \texttt{Událost dokončena v čase 3}. Tento příklad demonstruje, že callback je funkce spouštěná po dokončení události. V SimPy ale callbacky vznikají automaticky, když aktivita vrací \texttt{yield} událost.

\subsubsection{Vyvolání nastání události}
Jakmile událost nastane, může skončit úspěně, nebo selhat. Úspěšné nastání události můžeme vyvolat voláním metody \texttt{Event.succeed()}, která může volitelně nést návratovou hodnotu představující výsledek dané činnosti. Tato hodnota je následně předána procesům čekajícím na danou událost.

V případě, že během zpracování procesní funkce dojde k chybovému stavu, lze událost vyhodnotit jako neúspěšnou voláním metody \texttt{Event.fail()}. Tato metoda přijímá instanci výjimky, která je následně vyvolána v procesu čekajícím na danou událost, čímž je umožněno standardní ošetření chybových stavů.

SimPy rovněž poskytuje obecný mechanismus volání události prostřednictvím metody \texttt{Event.trigger()}, která převezme výsledek i stav (úspěch či selhání) jiné události. Tento přístup je vhodný zejména v případech, kdy je požadováno přeposílání výsledků mezi událostmi bez nutnosti explicitně rozlišovat jejich stav.

Metody \texttt{Event.succeed()} a \texttt{Event.fail()} vracejí instanci události, ke které náleží, což umožňuje jejich použití přímo ve výrazu \texttt{yield}. Naproti tomu metoda \texttt{Event.trigger()} návratovou hodnotu neposkytuje.

Následující příklad ilustruje použití vyvolání události metodou \texttt{Event.fail()}. V příkladu je modelována situace, kdy entita manažera \texttt{manager} zadá entitě dělníka \texttt{worker} úkol na tři časové jednotky, například hodiny, a čeká na dokončení jeho úkolu prostřednictvím události \texttt{done\_event}. Událost dokončení úkolu může nastat úspěšně, nebo selhat a v tomto simulujeme, že se úkol nepodařilo splnit. Tento příklad demonstruje mechanismus předávání výsledku mezi procesy a ošetření případné výjimky.

\begin{verbatim}
def worker(env, done_event):
    yield env.timeout(3)
    done_event.fail(RuntimeError("Worker: Úkol se nepodařilo splnit"))

def manager(env):
    print("Manager: Zadávám úkol na 3 hodiny")
    done_event = simpy.Event(env)
    env.process(worker(env, done_event))

    try:
        yield done_event

    except RuntimeError as e:
        print(e)

env = simpy.Environment()
env.process(manager(env))
env.run()
\end{verbatim}

V ukázce procesní funkce \texttt{manager} inicializuje simulaci a vytváří událost \texttt{done\_event}, která slouží k synchronizaci s procesní funkcí \texttt{worker}. 
Proces \texttt{worker} reprezentuje vykonání úkolu, který trvá tři časové jednotky, a po jejich uplynutí vyvolá neúspěšné nastání události voláním metody \texttt{Event.fail()}.
Před voláním \texttt{done\_event.fail(..)} by samozřejmě byl kód obsluhující pokus o splnění úkolu od manažera, ten však v této ukázce není podstatný. Proces \texttt{manager} čeká na nastání této události pomocí příkazu \texttt{yield done\_event}. Jakmile \texttt{worker} vyvolá neúspěšné nastání události, dojde k vyvolání výjimky v procesu \texttt{manager}, která je následně zachycena blokem \texttt{try-except}. V simulaci se tímto mechanismem demonstruje, jak je možné 
modelovat a ošetřovat chybové stavy mezi procesy a předávat informace o úspěchu či selhání činností.

Pro zajištění simultánního průběhu procesů je v těle funkce \texttt{manager} volána metoda \texttt{env.process(worker(env, done\_event))}, čímž je proces \texttt{worker} registrován u simulačního prostředí a spuštěn paralelně s procesem \texttt{manager}. Současně je proces \texttt{manager} registrován a spuštěn voláním 
\texttt{env.process(manager(env))} na konci ukázky. Toto dvojí volání \texttt{env.process} ilustruje, že v SimPy může být současně aktivních více procesů, které se vzájemně 
synchronizují prostřednictvím událostí.


Výstup tohoto příkladu by vypadal následovně:
\begin{verbatim}
Manager: Zadávám úkol na 3 hodiny
Worker: Úkol se nepodařilo splnit
\end{verbatim}

\subsubsection{Procesy jsou také události}

\end{document}

