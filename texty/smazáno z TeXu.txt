\subsection{Kdy je simulace vhodná} str7
Simulace je vhodná zejména v případech, kdy je potřeba detailně zkoumat vnitřní interakce složitých systémů nebo jejich částí. Díky možnosti měnit vstupní parametry a pozorovat výstupy se dají identifikovat klíčové proměnné a vztahy mezi nimi. Simulace také slouží jako efektivní nástroj pro výuku a demonstraci analytických metod. Simulace také umožňuje získávat data ze simulovaného systému v bezpečném prostředí bez nákladů a rizik spojených s reálným provozem. Pomocí animací lze také lépe vizualizovat fungování systému. U velmi složitých moderních systémů je simulace často jediným praktickým nástrojem, jak porozumět jejich vnitřním interakcím.

\subsection{Kdy simulaci nepoužívat} str8
Existují situace, kdy simulace není vhodná. Pokud je problém řešitelný jednoduchým rozumovým odhadem nebo základním výpočtem. V některých případech je navíc levnější provést přímý experiment než složitou simulaci. Pokud náklady na provedení simulace převyšují možné úspory nebo přínosy, simulace není ekonomicky výhodná. Důležitým faktorem je také schopnost model validovat a ověřit, protože bez dostatečné validace nemůžeme výsledkům simulace plně důvěřovat.

\section{Diskrétní simulace}str. 19
Simulace diskrétních systémů představuje modelování systémů, ve kterých se stavové proměnné mění pouze v diskrétní množině časových okamžiků. Tyto modely se neřeší analytickými, ale numerickými metodami. Analytické metody využívají deduktivní přístup matematiky k řešení modelu, například pomocí diferenciálního počtu lze stanovit optimální zásobovací politiku s minimálními náklady. Naproti tomu numerické metody používají výpočetní postupy, při nichž se modely nespočítají, ale simulují.
Simulační modely reálných systémů bývají často rozsáhlé a vyžadují zpracování velkého množství dat, proto se tyto simulace obvykle provádějí s pomocí počítače.


//SIMPY část//
 Umožňuje popisovat systémy pomocí procesů, které představují jednotlivé entity nebo činnosti v systému, a které mezi sebou mohou interagovat prostřednictvím událostí. Každý proces je v SimPy implementován jako generátor (funkce využívající klíčové slovo \texttt{yield}), což umožňuje simulovat plynutí času a pozastavovat vykonávání procesů, dokud nenastane určitá událost.

Základním prvkem simulace je objekt \texttt{Environment}, který reprezentuje simulační prostředí. Tento objekt řídí běh celé simulace, spravuje plán událostí a posouvá simulační čas. Kdykoliv proces použije příkaz \texttt{yield}, předává řízení zpět prostředí \texttt{Environment}, které vyhodnotí, jaká událost má nastat jako další. Po uplynutí naplánovaného času nebo splnění podmínky je proces znovu spuštěn od místa, kde byl pozastaven.

SimPy poskytuje také třídy \texttt{Resource}, \texttt{Container} a \texttt{Store}, které slouží k modelování omezených zdrojů, jako jsou fronty, zásoby nebo datové toky. Tyto objekty umožňují řídit interakce mezi procesy a simulovat situace, kdy více entit soutěží o stejný prostředek – například fronty návštěvníků čekajících u stánku s jídlem.  



\\CALLBACKY
Každá událost má také seznam callback funkcí, které se spustí, když je událost vyvolána a zpracována smyčkou událostí. V SimPy se každý proces, který vrací \texttt{yield} událost, interně přidává do seznamu callbacků této události. Callbacky jsou funkce, které se spustí, když je událost dokončena. Díky tomu aktivita pokračuje přesně tam, kde byla pozastavena. Tento mechanismus umožňuje přirozené střídání aktivit a souběžné chování více entit, aniž bychom museli ručně řídit, kdo právě běží. Callback tedy reaguje na dokončení události. Aktivity, které čekají na událost, jsou jedním typem callbacků. Můžeme si ale callbacky definovat i explicitně, například pokud chceme, aby se po dokončení Timeout události spustila nějaká další funkce. To si ukážeme v následujícím příkladu:

 \begin{verbatim} 
def my_callback(event):
    print(f"Událost dokončena v čase {event.env.now}, hodnota: {event.value}")

env = simpy.Environment()
event = env.timeout(3, value=42)
event.callbacks.append(my_callback)

env.run()
\end{verbatim}

Vytvořili jsme timeout událost na 3 časové jednotky. Přidali jsme callback \texttt{my\_callback}, který se automaticky spustí, když timeout skončí. Když SimPy zpracuje událost, zavolá callback a vypíše zprávu \texttt{Událost dokončena v čase 3, hodnota: 42}. Tento příklad demonstruje, že callback je funkce spouštěná po dokončení události. V SimPy ale callbacky vznikají automaticky, když aktivita vrací \texttt{yield} událost, to je hlavní mechanismus, díky kterému simulace běží sama.
